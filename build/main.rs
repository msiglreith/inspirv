
extern crate json;

mod ident;

use std::path::Path;
use std::io::{Result, Write};
use std::fs::{DirBuilder, File};

// Build SPIR-V information depeding on the official grammar
fn main() {
    println!("cargo:rerun-if-changed=build/main.rs");
    println!("cargo:rerun-if-changed=grammar/spirv.core.grammar.json");

    // Load SPIR-V grammar from the official Khronos registry
    // Current version: SPIR-V 1.1
    // TODO: load .json directly from registry: "https://www.khronos.org/registry/spir-v/api/1.1/spirv.core.grammar.json"
    let grammar = json::parse(include_str!("../grammar/spirv.core.grammar.json")).unwrap();

    // Generate code for the core instruction set of the SPIR-V specification
    let core_dir = Path::new("src/core");
    DirBuilder::new().recursive(true).create(core_dir).unwrap();
    build_core_mod(core_dir.join("mod.rs"), &grammar).unwrap();
    build_core_instructions(core_dir.join("instruction.rs"), &grammar).unwrap();
    build_core_enum(core_dir.join("enumeration.rs"), &grammar).unwrap();
}

/// Generate basic data for the core instruction set
fn build_core_mod<P: AsRef<Path>>(path: P, grammar: &json::JsonValue) -> Result<()> {
    let mut dest = ident::IdentWriter::new(File::create(path).unwrap());

    try!(writeln!(dest, "// WARNING: Generated by `build/main.rs`, do NOT change manually!"));
    try!(writeln!(dest, ""));

    try!(writeln!(dest, "pub mod instruction;"));
    try!(writeln!(dest, "pub mod enumeration;"));
    try!(writeln!(dest, ""));

    try!(writeln!(dest, "pub const SPIRV_MAGIC: u32 = {};", grammar["magic_number"]));
    try!(writeln!(dest, "pub const SPIRV_VERSION: (u32, u32) = ({major}, {minor});",
        major=grammar["major_version"],
        minor=grammar["minor_version"]
    ));
    try!(writeln!(dest, "pub const SPIRV_REVISION: u32 = {};", grammar["revision"]));

    Ok(())
}

/// Generate instruction data for the core instruction set
fn build_core_instructions<P: AsRef<Path>>(path: P, grammar: &json::JsonValue) -> Result<()> {
    let mut dest = ident::IdentWriter::new(File::create(path).unwrap());

    // file header
    try!(writeln!(dest, "// WARNING: Generated by `build/main.rs`, do NOT change manually!"));
    try!(writeln!(dest, "use types::*;"));
    try!(writeln!(dest, "use read_binary::{{RawInstructionView, ReadBinaryExt}};"));
    try!(writeln!(dest, "use instruction::Instruction;"));
    try!(writeln!(dest, "use core::enumeration::*;"));
    try!(writeln!(dest, "use io::ReadError;"));
    try!(writeln!(dest, ""));

    try!(writeln!(dest, "enum_from_primitive! {{"));
    try!(writeln!(dest, "pub enum OpCode {{")); dest.ident(); {
        for op in grammar["instructions"].members() {
            try!(writeln!(dest, "{name} = {value},", name=op["opname"], value=op["opcode"]));
        }
    } dest.unident(); try!(writeln!(dest, "}}}}"));
    try!(writeln!(dest, ""));

    for op in grammar["instructions"].members() {
        if op["operands"].is_null() {
            try!(writeln!(dest, "pub struct {};", op["opname"]));
        }
        else {
            try!(writeln!(dest, "pub struct {}(", op["opname"])); dest.ident(); {
                for operand in op["operands"].members() {
                    let comment = if !operand["name"].is_null() {
                        format!(" // {}", operand["name"]).chars().filter(|c| *c != '\n').collect::<String>()
                    } else {
                        String::new()
                    };

                    if operand["quantifier"].is_null() {
                        try!(writeln!(dest, "{ty},{comment}", ty=operand["kind"], comment=comment));
                    } else if operand["quantifier"] == "?" {
                        try!(writeln!(dest, "Option<{ty}>,{comment}", ty=operand["kind"], comment=comment));             
                    } else if operand["quantifier"] == "*" {
                        try!(writeln!(dest, "Vec<{ty}>,{comment}", ty=operand["kind"], comment=comment)); // TODO: emit Vec<_>?
                    } else {
                        unimplemented!();
                    };
                }
            } dest.unident(); try!(writeln!(dest, ");"));
        }
        try!(writeln!(dest, ""));

        try!(writeln!(dest, "impl Instruction for {} {{", op["opname"])); dest.ident(); {
            try!(writeln!(dest, "type OpCodeType = OpCode;"));
            try!(writeln!(dest, "fn opcode() -> Self::OpCodeType {{ OpCode::{} }}", op["opname"]));
        } dest.unident(); try!(writeln!(dest, "}}"));
        try!(writeln!(dest, ""));

        try!(writeln!(dest, "impl ReadBinaryExt for {} {{", op["opname"])); dest.ident(); {
            try!(writeln!(dest, "fn read(view: &mut RawInstructionView) -> Result<Self, ReadError> {{")); dest.ident(); {
                if op["operands"].is_null() {
                    try!(writeln!(dest, "Ok({instruction})", instruction=op["opname"]));
                } else {
                    try!(writeln!(dest, "Ok({instruction} (", instruction=op["opname"])); dest.ident(); {
                        for operand in op["operands"].members() {
                            if operand["quantifier"].is_null() {
                                try!(writeln!(dest, "try!({ty}::read(view)),", ty=operand["kind"]));
                            } else if operand["quantifier"] == "?" {
                                try!(writeln!(dest, "try!(Option::<{ty}>::read(view)),", ty=operand["kind"]));             
                            } else if operand["quantifier"] == "*" {
                                try!(writeln!(dest, "try!(Vec::<{ty}>::read(view)),", ty=operand["kind"])); // TODO: emit Vec<_>?
                            } else {
                                unimplemented!();
                            };
                        }
                    } dest.unident(); try!(writeln!(dest, "))"));
                }
            } dest.unident(); try!(writeln!(dest, "}}"));
        } dest.unident(); try!(writeln!(dest, "}}"));
        try!(writeln!(dest, ""));
    }

    Ok(())
}

/// Generate enumeration data for the core instruction set
fn build_core_enum<P: AsRef<Path>>(path: P, grammar: &json::JsonValue) -> Result<()> {
    let mut dest = ident::IdentWriter::new(File::create(path).unwrap());

    try!(writeln!(dest, "// WARNING: Generated by `build/main.rs`, do NOT change manually!"));
    try!(writeln!(dest, "use read_binary::{{RawInstructionView, ReadBinaryExt}};"));
    try!(writeln!(dest, "use io::ReadError;"));
    try!(writeln!(dest, "use num_traits::FromPrimitive;"));
    try!(writeln!(dest, ""));

    for op_kind in grammar["operand_kinds"].members() {
        let kind_type = op_kind["category"].as_str().unwrap();
        let has_parameters = {
            let mut param_found = false;
            for enumerant in op_kind["enumerants"].members() {
                if !enumerant["parameters"].is_null() {
                    param_found = true;
                    break;
                }
            }
            param_found
        };

        match kind_type {
            "ValueEnum" => {
                // generate new C-like enum
                if has_parameters {
                    // emit C-like kind of the enum excluding the parameters
                    let ref enum_name = op_kind["kind"];
                    try!(writeln!(dest, "enum_from_primitive! {{"));
                    try!(writeln!(dest, "#[derive(Debug)]"));
                    
                    try!(writeln!(dest, "pub enum {}Kind {{", enum_name)); dest.ident(); {
                        for enumerant in op_kind["enumerants"].members() {
                            // prefix required due to some enums like '1D', '2D', etc.
                            try!(writeln!(dest, "{prefix}{name} = {value},",
                                    name=enumerant["enumerant"],
                                    prefix=enum_name,
                                    value=enumerant["value"]
                            ));
                        }
                    } dest.unident(); try!(writeln!(dest, "}}}}"));
                    try!(writeln!(dest, ""));

                    try!(writeln!(dest, "impl ReadBinaryExt for {enum_name}Kind {{", enum_name=enum_name)); dest.ident(); {
                        try!(writeln!(dest, "fn read(view: &mut RawInstructionView) -> Result<Self, ReadError> {{")); dest.ident(); {
                            try!(writeln!(dest, "let word = try!(u32::read(view));"));
                            try!(writeln!(dest, "if let Some(val) = {enum_name}Kind::from_u32(word) {{ Ok(val) }}", enum_name=enum_name));
                            try!(writeln!(dest, "else {{ Err(ReadError::InvalidEnumValue(word)) }}"));
                        } dest.unident(); try!(writeln!(dest, "}}"));
                    } dest.unident(); try!(writeln!(dest, "}}"));
                    try!(writeln!(dest, ""));

                    // emit actual enum with parameters
                    try!(writeln!(dest, "#[derive(Debug)]"));
                    try!(writeln!(dest, "pub enum {} {{", enum_name)); dest.ident(); {
                         for enumerant in op_kind["enumerants"].members() {
                            // prefix required due to some enums like '1D', '2D', etc.
                            // TODO: emit parameters
                            try!(writeln!(dest, "{prefix}{name},",
                                    name=enumerant["enumerant"],
                                    prefix=enum_name
                            ));
                        }
                    } dest.unident(); try!(writeln!(dest, "}}"));
                    try!(writeln!(dest, ""));

                    try!(writeln!(dest, "impl ReadBinaryExt for {enum_name} {{", enum_name=enum_name)); dest.ident(); {
                        try!(writeln!(dest, "fn read(view: &mut RawInstructionView) -> Result<Self, ReadError> {{")); dest.ident(); {
                            try!(writeln!(dest, "unimplemented!()"));
                        } dest.unident(); try!(writeln!(dest, "}}"));
                    } dest.unident(); try!(writeln!(dest, "}}"));
                    try!(writeln!(dest, ""));

                } else {
                    let ref enum_name = op_kind["kind"];
                    try!(writeln!(dest, "enum_from_primitive! {{"));
                    try!(writeln!(dest, "#[derive(Debug)]"));
                    
                    try!(writeln!(dest, "pub enum {} {{", enum_name)); dest.ident(); {
                        for enumerant in op_kind["enumerants"].members() {
                            // prefix required due to some enums like '1D', '2D', etc.
                            try!(writeln!(dest, "{prefix}{name} = {value},",
                                    name=enumerant["enumerant"],
                                    prefix=enum_name,
                                    value=enumerant["value"]
                            ));
                        }
                    } dest.unident(); try!(writeln!(dest, "}}}}"));
                    try!(writeln!(dest, ""));

                    try!(writeln!(dest, "impl ReadBinaryExt for {enum_name} {{", enum_name=enum_name)); dest.ident(); {
                        try!(writeln!(dest, "fn read(view: &mut RawInstructionView) -> Result<Self, ReadError> {{")); dest.ident(); {
                            try!(writeln!(dest, "let word = try!(u32::read(view));"));
                            try!(writeln!(dest, "if let Some(val) = {enum_name}::from_u32(word) {{ Ok(val) }}", enum_name=enum_name));
                            try!(writeln!(dest, "else {{ Err(ReadError::InvalidEnumValue(word)) }}"));
                        } dest.unident(); try!(writeln!(dest, "}}"));
                    } dest.unident(); try!(writeln!(dest, "}}"));
                    try!(writeln!(dest, ""));
                }
            },

            "BitEnum" => {
                // generate bitflags
                let ref enum_name = op_kind["kind"];
                try!(writeln!(dest, "bitflags! {{")); dest.ident(); {
                    try!(writeln!(dest, "pub flags {}: u32 {{", enum_name)); dest.ident(); {
                        for enumerant in op_kind["enumerants"].members() {
                            try!(writeln!(dest, "const {prefix}{name} = {value},",
                                    name=enumerant["enumerant"],
                                    prefix=enum_name,
                                    value=enumerant["value"]
                            ));
                        }
                    } dest.unident(); try!(writeln!(dest, "}}"));
                } dest.unident(); try!(writeln!(dest, "}}"));
                try!(writeln!(dest, ""));

                try!(writeln!(dest, "impl ReadBinaryExt for {enum_name} {{", enum_name=enum_name)); dest.ident(); {
                    try!(writeln!(dest, "fn read(view: &mut RawInstructionView) -> Result<Self, ReadError> {{")); dest.ident(); {
                        try!(writeln!(dest, "let word = try!(u32::read(view));"));
                        try!(writeln!(dest, "if let Some(val) = {enum_name}::from_bits(word) {{ Ok(val) }}", enum_name=enum_name));
                        try!(writeln!(dest, "else {{ Err(ReadError::InvalidEnumValue(word)) }}"));
                    } dest.unident(); try!(writeln!(dest, "}}"));
                } dest.unident(); try!(writeln!(dest, "}}"));
                try!(writeln!(dest, ""));
            },

            _ => (),
        }
    }

    Ok(())
}
