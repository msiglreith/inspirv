
extern crate json;

mod ident;

use std::path::Path;
use std::io::{Result, Write};
use std::fs::{DirBuilder, File};

// Build SPIR-V information depeding on the official grammar
fn main() {
    println!("cargo:rerun-if-changed=build/main.rs");
    println!("cargo:rerun-if-changed=grammar/spirv.core.grammar.json");

    // Load SPIR-V grammar from the official Khronos registry
    // Current version: SPIR-V 1.1
    // TODO: low: load .json directly from registry: "https://www.khronos.org/registry/spir-v/api/1.1/spirv.core.grammar.json"
    let grammar = json::parse(include_str!("../grammar/spirv.core.grammar.json")).unwrap();

    // Generate code for the core instruction set of the SPIR-V specification
    let core_dir = Path::new("src/core");
    DirBuilder::new().recursive(true).create(core_dir).unwrap();
    build_core_mod(core_dir.join("mod.rs"), &grammar).unwrap();
    build_core_instructions(core_dir.join("instruction.rs"), &grammar).unwrap();
    build_core_enum(core_dir.join("enumeration.rs"), &grammar).unwrap();
}

/// Generate basic data for the core instruction set
fn build_core_mod<P: AsRef<Path>>(path: P, grammar: &json::JsonValue) -> Result<()> {
    let mut dest = ident::IdentWriter::new(File::create(path).unwrap());

    try!(writeln!(dest, "// WARNING: Generated by `build/main.rs`, do NOT change manually!"));
    try!(writeln!(dest, ""));

    try!(writeln!(dest, "pub mod instruction;"));
    try!(writeln!(dest, "pub mod enumeration;"));
    try!(writeln!(dest, ""));

    try!(writeln!(dest, "pub const SPIRV_MAGIC: u32 = {};", grammar["magic_number"]));
    try!(writeln!(dest, "pub const SPIRV_VERSION: (u32, u32) = ({major}, {minor});",
        major=grammar["major_version"],
        minor=grammar["minor_version"]
    ));
    try!(writeln!(dest, "pub const SPIRV_REVISION: u32 = {};", grammar["revision"]));

    Ok(())
}

/// Generate instruction data for the core instruction set
fn build_core_instructions<P: AsRef<Path>>(path: P, grammar: &json::JsonValue) -> Result<()> {
    let mut dest = ident::IdentWriter::new(File::create(path).unwrap());

    // file header
    try!(writeln!(dest, "// WARNING: Generated by `build/main.rs`, do NOT change manually!"));
    try!(writeln!(dest, "use types::*;"));
    try!(writeln!(dest, "use read_binary::{{RawInstructionView, ReadBinaryExt}};"));
    try!(writeln!(dest, "use write_binary::WriteBinaryExt;"));
    try!(writeln!(dest, "use instruction::{{InstructionExt, RawInstruction}};"));
    try!(writeln!(dest, "use core::enumeration::*;"));
    try!(writeln!(dest, "use io::ReadError;"));
    try!(writeln!(dest, ""));

    try!(writeln!(dest, "enum_from_primitive! {{"));
    try!(writeln!(dest, "#[derive(Clone, Copy, Debug)]"));
    try!(writeln!(dest, "pub enum OpCode {{")); dest.ident(); {
        for op in grammar["instructions"].members() {
            try!(writeln!(dest, "{name} = {value},", name=op["opname"], value=op["opcode"]));
        }
    } dest.unident(); try!(writeln!(dest, "}}}}"));
    try!(writeln!(dest, ""));

    // enum for all instructions in core
    try!(writeln!(dest, "#[derive(Clone, Debug)]"));
    try!(writeln!(dest, "pub enum Instruction {{")); dest.ident(); {
        for op in grammar["instructions"].members() {
            try!(writeln!(dest, "{name}({name}),", name=op["opname"]));
        }
    } dest.unident(); try!(writeln!(dest, "}}"));
    try!(writeln!(dest, ""));

    try!(writeln!(dest, "impl Instruction {{")); dest.ident(); {
        try!(writeln!(dest, "pub fn from_raw(opcode: OpCode, view: &mut RawInstructionView) -> Result<Self, ReadError> {{")); dest.ident(); {
            try!(writeln!(dest, "let instr = match opcode {{")); dest.ident(); {
                for op in grammar["instructions"].members() {
                    try!(writeln!(dest, "OpCode::{name} => Instruction::{name}(try!({name}::read(view))),", name=op["opname"]));
                }
            } dest.unident(); try!(writeln!(dest, "}};"));
            try!(writeln!(dest, "Ok(instr)"));
        } dest.unident(); try!(writeln!(dest, "}}"));
        try!(writeln!(dest, "pub fn to_raw(&self) -> RawInstruction {{")); dest.ident(); {
            try!(writeln!(dest, "let mut raw_instr = RawInstruction {{ opcode: self.opcode() as u32, operands: Vec::new() }};"));
            try!(writeln!(dest, "match self {{")); dest.ident(); {
                for op in grammar["instructions"].members() {
                    try!(writeln!(dest, "&Instruction::{name}(ref instr) => instr.write(&mut raw_instr),", name=op["opname"]));
                }
            } dest.unident(); try!(writeln!(dest, "}};"));
            try!(writeln!(dest, "raw_instr"));
        } dest.unident(); try!(writeln!(dest, "}}"));
    } dest.unident(); try!(writeln!(dest, "}}"));
    try!(writeln!(dest, ""));

    try!(writeln!(dest, "impl InstructionExt for Instruction {{")); dest.ident(); {
        try!(writeln!(dest, "type OpCodeType = OpCode;"));
        try!(writeln!(dest, "fn opcode(&self) -> Self::OpCodeType {{")); dest.ident(); {
            try!(writeln!(dest, "match self {{")); dest.ident(); {
                for op in grammar["instructions"].members() {
                    try!(writeln!(dest, "&Instruction::{name}(_) => OpCode::{name},", name=op["opname"]));
                }
            } dest.unident(); try!(writeln!(dest, "}}"));
        } dest.unident(); try!(writeln!(dest, "}}"));
    } dest.unident(); try!(writeln!(dest, "}}"));
    try!(writeln!(dest, ""));

    // generate data for each instruction
    for op in grammar["instructions"].members() {
        try!(writeln!(dest, "#[derive(Clone, Debug)]"));
        if op["operands"].is_null() {
            try!(writeln!(dest, "pub struct {};", op["opname"]));
        }
        else {
            try!(writeln!(dest, "pub struct {}(", op["opname"])); dest.ident(); {
                for operand in op["operands"].members() {
                    let comment = if !operand["name"].is_null() {
                        format!(" // {}", operand["name"]).chars().filter(|c| *c != '\n').collect::<String>()
                    } else {
                        String::new()
                    };

                    if operand["quantifier"].is_null() {
                        try!(writeln!(dest, "pub {ty},{comment}", ty=operand["kind"], comment=comment));
                    } else if operand["quantifier"] == "?" {
                        try!(writeln!(dest, "pub Option<{ty}>,{comment}", ty=operand["kind"], comment=comment));             
                    } else if operand["quantifier"] == "*" {
                        try!(writeln!(dest, "pub Vec<{ty}>,{comment}", ty=operand["kind"], comment=comment)); // TODO: emit Vec<_>?
                    } else {
                        unimplemented!();
                    };
                }
            } dest.unident(); try!(writeln!(dest, ");"));
        }
        try!(writeln!(dest, ""));

        try!(writeln!(dest, "impl InstructionExt for {} {{", op["opname"])); dest.ident(); {
            try!(writeln!(dest, "type OpCodeType = OpCode;"));
            try!(writeln!(dest, "fn opcode(&self) -> Self::OpCodeType {{ OpCode::{} }}", op["opname"]));
        } dest.unident(); try!(writeln!(dest, "}}"));

        try!(writeln!(dest, "impl ReadBinaryExt for {} {{", op["opname"])); dest.ident(); {
            try!(writeln!(dest, "fn read(view: &mut RawInstructionView) -> Result<Self, ReadError> {{")); dest.ident(); {
                if op["operands"].is_null() {
                    try!(writeln!(dest, "Ok({instruction})", instruction=op["opname"]));
                } else {
                    try!(writeln!(dest, "Ok({instruction} (", instruction=op["opname"])); dest.ident(); {
                        for operand in op["operands"].members() {
                            if operand["quantifier"].is_null() {
                                try!(writeln!(dest, "try!({ty}::read(view)),", ty=operand["kind"]));
                            } else if operand["quantifier"] == "?" {
                                try!(writeln!(dest, "try!(Option::<{ty}>::read(view)),", ty=operand["kind"]));             
                            } else if operand["quantifier"] == "*" {
                                try!(writeln!(dest, "try!(Vec::<{ty}>::read(view)),", ty=operand["kind"])); // TODO: emit Vec<_>?
                            } else {
                                unimplemented!();
                            };
                        }
                    } dest.unident(); try!(writeln!(dest, "))"));
                }
            } dest.unident(); try!(writeln!(dest, "}}"));
        } dest.unident(); try!(writeln!(dest, "}}"));

        try!(writeln!(dest, "impl WriteBinaryExt for {} {{", op["opname"])); dest.ident(); {
            try!(writeln!(dest, "fn write(&self, instr: &mut RawInstruction) {{")); dest.ident(); {
                let mut cur_operand = 0;
                for _ in op["operands"].members() {
                    try!(writeln!(dest, "self.{num}.write(instr);", num=cur_operand));
                    cur_operand += 1;
                }
            } dest.unident(); try!(writeln!(dest, "}}"));
        } dest.unident(); try!(writeln!(dest, "}}"));
        try!(writeln!(dest, ""));
    }

    Ok(())
}

/// Generate enumeration data for the core instruction set
fn build_core_enum<P: AsRef<Path>>(path: P, grammar: &json::JsonValue) -> Result<()> {
    let mut dest = ident::IdentWriter::new(File::create(path).unwrap());

    try!(writeln!(dest, "// WARNING: Generated by `build/main.rs`, do NOT change manually!"));
    try!(writeln!(dest, "use read_binary::{{RawInstructionView, ReadBinaryExt}};"));
    try!(writeln!(dest, "use write_binary::WriteBinaryExt;"));
    try!(writeln!(dest, "use instruction::RawInstruction;"));
    try!(writeln!(dest, "use io::ReadError;"));
    try!(writeln!(dest, "use num_traits::FromPrimitive;"));
    try!(writeln!(dest, "use types::*;"));
    try!(writeln!(dest, ""));

    for op_kind in grammar["operand_kinds"].members() {
        let kind_type = op_kind["category"].as_str().unwrap();
        let has_parameters = {
            let mut param_found = false;
            for enumerant in op_kind["enumerants"].members() {
                if !enumerant["parameters"].is_null() {
                    param_found = true;
                    break;
                }
            }
            param_found
        };

        match kind_type {
            "ValueEnum" => {
                // generate new C-like enum
                if has_parameters {
                    // emit C-like kind of the enum excluding the parameters
                    let ref enum_name = op_kind["kind"];
                    try!(writeln!(dest, "enum_from_primitive! {{"));
                    try!(writeln!(dest, "#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]"));
                    
                    try!(writeln!(dest, "pub enum {}Kind {{", enum_name)); dest.ident(); {
                        for enumerant in op_kind["enumerants"].members() {
                            // prefix required due to some enums like '1D', '2D', etc.
                            try!(writeln!(dest, "{prefix}{name} = {value},",
                                    name=enumerant["enumerant"],
                                    prefix=enum_name,
                                    value=enumerant["value"]
                            ));
                        }
                    } dest.unident(); try!(writeln!(dest, "}}}}"));
                    try!(writeln!(dest, ""));

                    try!(writeln!(dest, "impl ReadBinaryExt for {enum_name}Kind {{", enum_name=enum_name)); dest.ident(); {
                        try!(writeln!(dest, "fn read(view: &mut RawInstructionView) -> Result<Self, ReadError> {{")); dest.ident(); {
                            try!(writeln!(dest, "let word = try!(u32::read(view));"));
                            try!(writeln!(dest, "if let Some(val) = {enum_name}Kind::from_u32(word) {{ Ok(val) }}", enum_name=enum_name));
                            try!(writeln!(dest, "else {{ Err(ReadError::InvalidEnumValue(word)) }}"));
                        } dest.unident(); try!(writeln!(dest, "}}"));
                    } dest.unident(); try!(writeln!(dest, "}}"));
                    try!(writeln!(dest, ""));

                    try!(writeln!(dest, "impl WriteBinaryExt for {enum_name}Kind {{", enum_name=enum_name)); dest.ident(); {
                        try!(writeln!(dest, "fn write(&self, instr: &mut RawInstruction) {{")); dest.ident(); {
                            try!(writeln!(dest, "(*self as u32).write(instr);"));
                        } dest.unident(); try!(writeln!(dest, "}}"));
                    } dest.unident(); try!(writeln!(dest, "}}"));
                    try!(writeln!(dest, ""));

                    // emit actual enum with parameters
                    try!(writeln!(dest, "#[derive(Clone, Debug)]"));
                    try!(writeln!(dest, "pub enum {} {{", enum_name)); dest.ident(); {
                         for enumerant in op_kind["enumerants"].members() {
                            // prefix required due to some enums like '1D', '2D', etc.
                            if enumerant["parameters"].is_null() {
                                try!(writeln!(dest, "{prefix}{name},",
                                    name=enumerant["enumerant"],
                                    prefix=enum_name
                                ));
                            } else {
                                try!(writeln!(dest, "{prefix}{name}(",
                                    name=enumerant["enumerant"],
                                    prefix=enum_name
                                )); dest.ident(); {
                                    for param in enumerant["parameters"].members() {
                                        let comment = if !param["name"].is_null() {
                                            format!(" // {}", param["name"]).chars().filter(|c| *c != '\n').collect::<String>()
                                        } else {
                                            String::new()
                                        };

                                        try!(writeln!(dest, "{ty},{comment}", ty=param["kind"], comment=comment));
                                    }
                                } dest.unident(); try!(writeln!(dest, "),"));
                            }
                        }
                    } dest.unident(); try!(writeln!(dest, "}}"));
                    try!(writeln!(dest, ""));

                    try!(writeln!(dest, "impl ReadBinaryExt for {enum_name} {{", enum_name=enum_name)); dest.ident(); {
                        try!(writeln!(dest, "fn read(view: &mut RawInstructionView) -> Result<Self, ReadError> {{")); dest.ident(); {
                            try!(writeln!(dest, "let kind = try!({enum_name}Kind::read(view));", enum_name=enum_name));
                            try!(writeln!(dest, "let mode = match kind {{")); dest.ident(); {
                                for enumerant in op_kind["enumerants"].members() {
                                    if enumerant["parameters"].is_null() {
                                        try!(writeln!(dest, "{enum_name}Kind::{prefix}{name} => {enum_name}::{prefix}{name},",
                                            enum_name=enum_name,
                                            prefix=enum_name,
                                            name=enumerant["enumerant"]
                                        ));
                                    } else {
                                        try!(writeln!(dest, "{enum_name}Kind::{prefix}{name} => {enum_name}::{prefix}{name}(",
                                            enum_name=enum_name,
                                            prefix=enum_name,
                                            name=enumerant["enumerant"]
                                        )); dest.ident(); { 
                                            for param in enumerant["parameters"].members() {
                                                try!(writeln!(dest, "try!({ty}::read(view)),", ty=param["kind"]));
                                            }
                                        } dest.unident(); try!(writeln!(dest, "),"));
                                    }
                                }
                            } dest.unident(); try!(writeln!(dest, "}};"));
                            try!(writeln!(dest, "Ok(mode)"));
                        } dest.unident(); try!(writeln!(dest, "}}"));
                    } dest.unident(); try!(writeln!(dest, "}}"));
                    try!(writeln!(dest, ""));

                     try!(writeln!(dest, "impl WriteBinaryExt for {enum_name} {{", enum_name=enum_name)); dest.ident(); {
                        try!(writeln!(dest, "fn write(&self, instr: &mut RawInstruction) {{")); dest.ident(); {
                            try!(writeln!(dest, "match *self {{")); dest.ident(); {
                                for enumerant in op_kind["enumerants"].members() {
                                    if enumerant["parameters"].is_null() {
                                        try!(writeln!(dest, "{enum_name}::{prefix}{name} => {enum_name}Kind::{prefix}{name}.write(instr),",
                                            enum_name=enum_name,
                                            prefix=enum_name,
                                            name=enumerant["enumerant"]));
                                    } else {
                                        try!(writeln!(dest, "{enum_name}::{prefix}{name}(",
                                            enum_name=enum_name,
                                            prefix=enum_name,
                                            name=enumerant["enumerant"]
                                        )); dest.ident(); {
                                            let mut cur_param = 0;
                                            for _ in enumerant["parameters"].members() {
                                                try!(writeln!(dest, "ref param{num},", num=cur_param));
                                                cur_param += 1;
                                            }
                                        } dest.unident(); try!(writeln!(dest, ") => {{")); dest.ident(); {
                                            try!(writeln!(dest, "{enum_name}Kind::{prefix}{name}.write(instr);",
                                                enum_name=enum_name,
                                                prefix=enum_name,
                                                name=enumerant["enumerant"]));
                                            let mut cur_param = 0;
                                            for _ in enumerant["parameters"].members() {
                                                try!(writeln!(dest, "param{num}.write(instr);", num=cur_param));
                                                cur_param += 1;
                                            }
                                        } dest.unident(); try!(writeln!(dest, "}},"));
                                    }
                                }
                            } dest.unident(); try!(writeln!(dest, "}}"));
                        } dest.unident(); try!(writeln!(dest, "}}"));
                    } dest.unident(); try!(writeln!(dest, "}}"));
                    try!(writeln!(dest, ""));

                } else {
                    // no parameters -> C-like enum only
                    let ref enum_name = op_kind["kind"];
                    try!(writeln!(dest, "enum_from_primitive! {{"));
                    try!(writeln!(dest, "#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]"));
                    
                    try!(writeln!(dest, "pub enum {} {{", enum_name)); dest.ident(); {
                        for enumerant in op_kind["enumerants"].members() {
                            // prefix required due to some enums like '1D', '2D', etc.
                            try!(writeln!(dest, "{prefix}{name} = {value},",
                                    name=enumerant["enumerant"],
                                    prefix=enum_name,
                                    value=enumerant["value"]
                            ));
                        }
                    } dest.unident(); try!(writeln!(dest, "}}}}"));
                    try!(writeln!(dest, ""));

                    try!(writeln!(dest, "impl ReadBinaryExt for {enum_name} {{", enum_name=enum_name)); dest.ident(); {
                        try!(writeln!(dest, "fn read(view: &mut RawInstructionView) -> Result<Self, ReadError> {{")); dest.ident(); {
                            try!(writeln!(dest, "let word = try!(u32::read(view));"));
                            try!(writeln!(dest, "if let Some(val) = {enum_name}::from_u32(word) {{ Ok(val) }}", enum_name=enum_name));
                            try!(writeln!(dest, "else {{ Err(ReadError::InvalidEnumValue(word)) }}"));
                        } dest.unident(); try!(writeln!(dest, "}}"));
                    } dest.unident(); try!(writeln!(dest, "}}"));

                    try!(writeln!(dest, "impl WriteBinaryExt for {enum_name} {{", enum_name=enum_name)); dest.ident(); {
                        try!(writeln!(dest, "fn write(&self, instr: &mut RawInstruction) {{")); dest.ident(); {
                            try!(writeln!(dest, "(*self as u32).write(instr);"));
                        } dest.unident(); try!(writeln!(dest, "}}"));
                    } dest.unident(); try!(writeln!(dest, "}}"));
                    try!(writeln!(dest, ""));
                }
            },

            "BitEnum" => {
                // TODO: high: correctly read/write enums with parameters
                // generate bitflags
                let ref enum_name = op_kind["kind"];
                try!(writeln!(dest, "bitflags! {{")); dest.ident(); {
                    try!(writeln!(dest, "pub flags {}: u32 {{", enum_name)); dest.ident(); {
                        for enumerant in op_kind["enumerants"].members() {
                            try!(writeln!(dest, "const {prefix}{name} = {value},",
                                    name=enumerant["enumerant"],
                                    prefix=enum_name,
                                    value=enumerant["value"]
                            ));
                        }
                    } dest.unident(); try!(writeln!(dest, "}}"));
                } dest.unident(); try!(writeln!(dest, "}}"));
                try!(writeln!(dest, ""));

                try!(writeln!(dest, "impl ReadBinaryExt for {enum_name} {{", enum_name=enum_name)); dest.ident(); {
                    try!(writeln!(dest, "fn read(view: &mut RawInstructionView) -> Result<Self, ReadError> {{")); dest.ident(); {
                        try!(writeln!(dest, "let word = try!(u32::read(view));"));
                        try!(writeln!(dest, "if let Some(val) = {enum_name}::from_bits(word) {{ Ok(val) }}", enum_name=enum_name));
                        try!(writeln!(dest, "else {{ Err(ReadError::InvalidEnumValue(word)) }}"));
                    } dest.unident(); try!(writeln!(dest, "}}"));
                } dest.unident(); try!(writeln!(dest, "}}"));

                try!(writeln!(dest, "impl WriteBinaryExt for {enum_name} {{", enum_name=enum_name)); dest.ident(); {
                        try!(writeln!(dest, "fn write(&self, instr: &mut RawInstruction) {{")); dest.ident(); {
                            try!(writeln!(dest, "self.bits().write(instr);"));
                        } dest.unident(); try!(writeln!(dest, "}}"));
                    } dest.unident(); try!(writeln!(dest, "}}"));
                    try!(writeln!(dest, ""));
            },

            _ => (),
        }
    }

    Ok(())
}
