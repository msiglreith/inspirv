
extern crate json;

mod ident;

use std::path::Path;
use std::io::{Result, Write};
use std::fs::{DirBuilder, File};

// Build SPIR-V information depeding on the official grammar
fn main() {
    // Load SPIR-V grammar from the official Khronos registry
    // Current version: SPIR-V 1.1
    // TODO: load .json directly from registry: "https://www.khronos.org/registry/spir-v/api/1.1/spirv.core.grammar.json"
    let grammar = json::parse(include_str!("../grammar/spirv.core.grammar.json")).unwrap();

    // Generate code for the core instruction set of the SPIR-V specification
    let core_dir = Path::new("src/core");
    DirBuilder::new().recursive(true).create(core_dir).unwrap();
    build_core_mod(core_dir.join("mod.rs"), &grammar).unwrap();
    build_core_instructions(core_dir.join("instruction.rs"), &grammar).unwrap();
    build_core_enum(core_dir.join("enumeration.rs"), &grammar).unwrap();
}

/// Generate basic data for the core instruction set
fn build_core_mod<P: AsRef<Path>>(path: P, grammar: &json::JsonValue) -> Result<()> {
    let mut dest = ident::IdentWriter::new(File::create(path).unwrap());

    try!(writeln!(dest, "// WARNING: Generated by `build/main.rs`, do NOT change manually!"));
    try!(writeln!(dest, ""));

    try!(writeln!(dest, "pub mod instruction;"));
    try!(writeln!(dest, "pub mod enumeration;"));
    try!(writeln!(dest, ""));

    try!(writeln!(dest, "pub const SPIRV_MAGIC: usize = {};", grammar["magic_number"]));
    try!(writeln!(dest, "pub const SPIRV_VERSION: (usize, usize) = ({major}, {minor});",
        major=grammar["major_version"],
        minor=grammar["minor_version"]
    ));
    try!(writeln!(dest, "pub const SPIRV_REVISION: usize = {};", grammar["revision"]));

    Ok(())
}

/// Generate instruction data for the core instruction set
fn build_core_instructions<P: AsRef<Path>>(path: P, grammar: &json::JsonValue) -> Result<()> {
    let mut dest = ident::IdentWriter::new(File::create(path).unwrap());

    try!(writeln!(dest, "// WARNING: Generated by `build/main.rs`, do NOT change manually!"));
    try!(writeln!(dest, ""));

    Ok(())
}

/// Generate enumeration data for the core instruction set
fn build_core_enum<P: AsRef<Path>>(path: P, grammar: &json::JsonValue) -> Result<()> {
    let mut dest = ident::IdentWriter::new(File::create(path).unwrap());

    try!(writeln!(dest, "// WARNING: Generated by `build/main.rs`, do NOT change manually!"));
    try!(writeln!(dest, ""));
    
    for op_kind in grammar["operand_kinds"].members() {
        let kind_type = op_kind["category"].as_str().unwrap();
        match kind_type {
            "ValueEnum" => {
                // generate new C-like enum
                let ref enum_name = op_kind["kind"];
                try!(writeln!(dest, "pub enum {} {{", enum_name));

                dest.ident(); {
                    for enumerant in op_kind["enumerants"].members() {
                        // prefix required due to some enums like '1D', '2D', etc.
                        try!(writeln!(dest, "{prefix}{name} = {value},",
                                name=enumerant["enumerant"],
                                prefix=enum_name,
                                value=enumerant["value"]
                        ));
                    }
                } dest.unident();

                try!(writeln!(dest, "}}"));
                try!(writeln!(dest, ""));
            },

            "BitEnum" => {
                // generate bitflags
                let ref enum_name = op_kind["kind"];
                try!(writeln!(dest, "bitflags! {{"));
                dest.ident(); {

                    try!(writeln!(dest, "pub flags {}: u32 {{", enum_name));
                    dest.ident(); {

                        for enumerant in op_kind["enumerants"].members() {
                            try!(writeln!(dest, "const {prefix}{name} = {value},",
                                    name=enumerant["enumerant"],
                                    prefix=enum_name,
                                    value=enumerant["value"]
                            ));
                        }

                    } dest.unident();
                    try!(writeln!(dest, "}}"));

                } dest.unident();
                try!(writeln!(dest, "}}"));
                try!(writeln!(dest, ""));
            },

            _ => (),
        }
    }

    Ok(())
}
