
extern crate json;

mod ident;

use std::path::Path;
use std::io::{Result, Write};
use std::fs::{DirBuilder, File};

// Build SPIR-V information depeding on the official grammar
fn main() {
    // Load SPIR-V grammar from the official Khronos registry
    // Current version: SPIR-V 1.1
    // TODO: load .json directly from registry: "https://www.khronos.org/registry/spir-v/api/1.1/spirv.core.grammar.json"
    let grammar = json::parse(include_str!("../grammar/spirv.core.grammar.json")).unwrap();

    // Generate code for the core instruction set of the SPIR-V specification
    let core_dir = Path::new("src/core");
    DirBuilder::new().recursive(true).create(core_dir).unwrap();
    build_core_mod(core_dir.join("mod.rs"), &grammar).unwrap();
    build_core_instructions(core_dir.join("instruction.rs"), &grammar).unwrap();
    build_core_enum(core_dir.join("enumeration.rs"), &grammar).unwrap();
}

/// Generate basic data for the core instruction set
fn build_core_mod<P: AsRef<Path>>(path: P, grammar: &json::JsonValue) -> Result<()> {
    let mut dest = ident::IdentWriter::new(File::create(path).unwrap());

    try!(writeln!(dest, "// WARNING: Generated by `build/main.rs`, do NOT change manually!"));
    try!(writeln!(dest, ""));

    try!(writeln!(dest, "pub mod instruction;"));
    try!(writeln!(dest, "pub mod enumeration;"));
    try!(writeln!(dest, ""));

    try!(writeln!(dest, "pub const SPIRV_MAGIC: usize = {};", grammar["magic_number"]));
    try!(writeln!(dest, "pub const SPIRV_VERSION: (usize, usize) = ({major}, {minor});",
        major=grammar["major_version"],
        minor=grammar["minor_version"]
    ));
    try!(writeln!(dest, "pub const SPIRV_REVISION: usize = {};", grammar["revision"]));

    Ok(())
}

/// Generate instruction data for the core instruction set
fn build_core_instructions<P: AsRef<Path>>(path: P, grammar: &json::JsonValue) -> Result<()> {
    let mut dest = ident::IdentWriter::new(File::create(path).unwrap());

    // file header
    try!(writeln!(dest, "// WARNING: Generated by `build/main.rs`, do NOT change manually!"));
    try!(writeln!(dest, "use types::*;"));
    try!(writeln!(dest, "use instruction::Instruction;"));
    try!(writeln!(dest, "use core::enumeration::*;"));
    try!(writeln!(dest, ""));

    try!(writeln!(dest, "pub enum OpCode {{"));
    dest.ident(); {
        for op in grammar["instructions"].members() {
            try!(writeln!(dest, "{name} = {value},", name=op["opname"], value=op["opcode"]));
        }
    } dest.unident();
    try!(writeln!(dest, ""));
    try!(writeln!(dest, "}}"));

    for op in grammar["instructions"].members() {
        if op["operands"].is_null() {
            try!(writeln!(dest, "pub struct {};", op["opname"]));
        }
        else {
            try!(writeln!(dest, "pub struct {}(", op["opname"]));
            dest.ident(); {
                for operand in op["operands"].members() {
                    let comment = if !operand["name"].is_null() {
                        format!(" // {}", operand["name"]).chars().filter(|c| *c != '\n').collect::<String>()
                    } else {
                        String::new()
                    };

                    if operand["quantifier"].is_null() {
                        try!(writeln!(dest, "{ty},{comment}", ty=operand["kind"], comment=comment));
                    } else if operand["quantifier"] == "?" {
                        try!(writeln!(dest, "Option<{ty}>,{comment}", ty=operand["kind"], comment=comment));             
                    } else if operand["quantifier"] == "*" {
                        try!(writeln!(dest, "Vec<{ty}>,{comment}", ty=operand["kind"], comment=comment)); // TODO: emit Vec<_
                    } else {
                        unimplemented!();
                    };
                }
            } dest.unident();
            try!(writeln!(dest, ");"));
        }
        try!(writeln!(dest, ""));

        try!(writeln!(dest, "impl Instruction for {} {{", op["opname"]));
        dest.ident(); {
            try!(writeln!(dest, "type OpCodeType = OpCode;"));
            try!(writeln!(dest, "fn opcode() -> Self::OpCodeType {{ OpCode::{} }}", op["opname"]));
        } dest.unident();
        try!(writeln!(dest, "}}"));
        try!(writeln!(dest, ""));
        }

    Ok(())
}

/// Generate enumeration data for the core instruction set
fn build_core_enum<P: AsRef<Path>>(path: P, grammar: &json::JsonValue) -> Result<()> {
    let mut dest = ident::IdentWriter::new(File::create(path).unwrap());

    try!(writeln!(dest, "// WARNING: Generated by `build/main.rs`, do NOT change manually!"));
    try!(writeln!(dest, ""));

    for op_kind in grammar["operand_kinds"].members() {
        let kind_type = op_kind["category"].as_str().unwrap();
        match kind_type {
            "ValueEnum" => {
                // generate new C-like enum
                let ref enum_name = op_kind["kind"];
                try!(writeln!(dest, "#[derive(Debug)]"));
                try!(writeln!(dest, "pub enum {} {{", enum_name));

                dest.ident(); {
                    for enumerant in op_kind["enumerants"].members() {
                        // prefix required due to some enums like '1D', '2D', etc.
                        try!(writeln!(dest, "{prefix}{name} = {value},",
                                name=enumerant["enumerant"],
                                prefix=enum_name,
                                value=enumerant["value"]
                        ));
                    }
                } dest.unident();

                try!(writeln!(dest, "}}"));
                try!(writeln!(dest, ""));
            },

            "BitEnum" => {
                // generate bitflags
                let ref enum_name = op_kind["kind"];
                try!(writeln!(dest, "bitflags! {{"));
                dest.ident(); {

                    try!(writeln!(dest, "pub flags {}: u32 {{", enum_name));
                    dest.ident(); {

                        for enumerant in op_kind["enumerants"].members() {
                            try!(writeln!(dest, "const {prefix}{name} = {value},",
                                    name=enumerant["enumerant"],
                                    prefix=enum_name,
                                    value=enumerant["value"]
                            ));
                        }

                    } dest.unident();
                    try!(writeln!(dest, "}}"));

                } dest.unident();
                try!(writeln!(dest, "}}"));
                try!(writeln!(dest, ""));
            },

            _ => (),
        }
    }

    Ok(())
}
